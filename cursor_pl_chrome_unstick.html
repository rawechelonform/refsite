<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crosshair — Chrome pointer-lock (never-stuck)</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font:14px/1.5 system-ui}
  .ui{position:fixed;left:0;right:0;top:0;padding:12px 14px;text-align:center;color:#aab}

  :root{--s:34px;--t:2px;--g:18px;--d:3px}
  #c{
    position:fixed;left:0;top:0;width:var(--s);height:var(--s);
    transform:translate(-50%,-50%);pointer-events:none;z-index:2147483646;
    color:#fff;filter:drop-shadow(0 0 1px #000) drop-shadow(0 0 2px #000) drop-shadow(0 0 3px #000);
    display:block
  }
  #c .arm{
    position:absolute;left:50%;top:50%;width:var(--s);height:var(--t);transform-origin:50% 50%;
    background:linear-gradient(90deg,currentColor 0 calc(50% - (var(--g)/2)),
      transparent calc(50% - (var(--g)/2)) calc(50% + (var(--g)/2)),
      currentColor calc(50% + (var(--g)/2)) 100%)}
  #c .arm-a{transform:translate(-50%,-50%) rotate(45deg)}
  #c .arm-b{transform:translate(-50%,-50%) rotate(-45deg)}
  #c .dot{position:absolute;left:50%;top:50%;width:var(--d);height:var(--d);transform:translate(-50%,-50%);border-radius:50%;background:currentColor}

  @keyframes spin{from{transform:translate(-50%,-50%) rotate(0)}to{transform:translate(-50%,-50%) rotate(360deg)}}
  #c.implode .arm-a,#c.implode .arm-b{animation:arm-implode 220ms ease-out forwards}
  @keyframes arm-implode{
    0%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(1)}
    60%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(.25)}
    100%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(0)}
  }
  #c.implode .arm-a{--deg:45deg} #c.implode .arm-b{--deg:-45deg}

  @media (prefers-reduced-motion: reduce){
    #c{animation:none !important}
    #c.implode .arm-a,#c.implode .arm-b{animation:none !important}
  }
</style>

<body>
  <div class="ui">Click to <b>lock</b>. Click while locked = squeeze. Hitting any edge instantly hands off to OS cursor. Esc also unlocks.</div>

  <div id="c" aria-hidden="true">
    <span class="arm arm-a"></span>
    <span class="arm arm-b"></span>
    <span class="dot"></span>
  </div>

<script>
(() => {
  // ----- Tuning -----
  const SENS   = 0.55;  // lower = less sensitive
  const DX_CAP = 24;    // cap raw per-frame delta (pre-scale)
  const DY_CAP = 24;
  const WATCHDOG_MS = 280; // if locked, at edge, and no deltas for this long → unlock

  const c = document.getElementById('c');

  let locked = false;
  let x = innerWidth/2, y = innerHeight/2;
  let lastMoveTs = 0;
  let lastEdge = null;       // 'left'|'right'|'top'|'bottom'|null

  const clamp = (v,min,max)=> v<min?min : v>max?max : v;
  const now   = ()=> performance.now();
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const prefersReduce = matchMedia('(prefers-reduced-motion: reduce)').matches;

  function paint(){ c.style.left = x+'px'; c.style.top = y+'px'; }

  // --- Pre-lock: follow OS cursor so crosshair is always visible ---
  function preMove(e){ if (!locked){ x = e.clientX; y = e.clientY; paint(); } }
  addEventListener('pointermove', preMove, { passive:true });

  // --- Edge detection ---
  function edgeOf(nx, ny){
    if (nx <= 0) return 'left';
    if (nx >= innerWidth-1) return 'right';
    if (ny <= 0) return 'top';
    if (ny >= innerHeight-1) return 'bottom';
    return null;
  }

  // --- Deltas (robust): listen to all sources on document, capture phase ---
  const getDX = ev => (ev.movementX ?? ev.webkitMovementX ?? ev.mozMovementX ?? 0);
  const getDY = ev => (ev.movementY ?? ev.webkitMovementY ?? ev.mozMovementY ?? 0);

  function applyDelta(ev){
    if (!locked) return;

    let dx = getDX(ev), dy = getDY(ev);
    if (!dx && !dy) return;

    // cap & scale for a sane feel
    if (dx > DX_CAP) dx = DX_CAP; else if (dx < -DX_CAP) dx = -DX_CAP;
    if (dy > DY_CAP) dy = DY_CAP; else if (dy < -DY_CAP) dy = -DY_CAP;
    dx *= SENS; dy *= SENS;

    let nx = clamp(x + dx, 0, innerWidth  - 1);
    let ny = clamp(y + dy, 0, innerHeight - 1);

    // INSTANT HANDOFF: touching any edge → unlock immediately (no push-direction check)
    const edge = edgeOf(nx, ny);
    if (edge){
      lastEdge = edge;
      c.style.display = 'none';        // avoid double-cursor flash on the handoff frame
      document.exitPointerLock?.();
      return;
    } else {
      lastEdge = null;
    }

    x = nx; y = ny;
    lastMoveTs = now();
    paint();
  }

  const onMM  = e => applyDelta(e);
  const onPM  = e => applyDelta(e);
  const onPRU = e => applyDelta(e);

  function addLocked(){
    document.addEventListener('mousemove',        onMM,  true);
    document.addEventListener('pointermove',      onPM,  true);
    document.addEventListener('pointerrawupdate', onPRU, true);
  }
  function removeLocked(){
    document.removeEventListener('mousemove',        onMM,  true);
    document.removeEventListener('pointermove',      onPM,  true);
    document.removeEventListener('pointerrawupdate', onPRU, true);
  }

  // --- Watchdog: if locked and starved of deltas at an edge → unlock anyway ---
  setInterval(() => {
    if (!locked) return;
    const atEdge = (x<=0 || x>=innerWidth-1 || y<=0 || y>=innerHeight-1);
    if (atEdge && (now() - lastMoveTs) > WATCHDOG_MS){
      c.style.display = 'none';
      document.exitPointerLock?.();
    }
  }, Math.max(60, WATCHDOG_MS/3));

  // --- Idle random spins (not on click) ---
  let spinTimer = null;
  function scheduleSpin(){
    clearTimeout(spinTimer);
    const delay = Math.round(rand(1200, 4200));
    spinTimer = setTimeout(() => {
      if (!prefersReduce && locked && (now()-lastMoveTs > 220)){
        const rev = Math.random() < 0.5;
        const dur = Math.round(rand(260, 680));
        c.style.animation = 'none'; void c.offsetWidth;
        c.style.animation = `spin ${dur}ms ease-out ${rev?'reverse':'normal'}`;
      }
      scheduleSpin();
    }, delay);
  }

  // --- Pointer-lock lifecycle ---
  function onLockChange(){
    locked = (document.pointerLockElement === document.body);
    if (locked){
      removeEventListener('pointermove', preMove, true);
      addLocked();
      c.style.display = 'block';
      paint();
    } else {
      removeLocked();
      addEventListener('pointermove', preMove, { passive:true });
      // crosshair will reappear on next pointermove over the page
    }
  }
  addEventListener('pointerlockchange', onLockChange);
  addEventListener('pointerlockerror',  onLockChange);

  // --- Safety: if the tab blurs or hides, unlock (prevents “stuck” feel) ---
  addEventListener('blur', () => { if (locked) document.exitPointerLock?.(); });
  addEventListener('visibilitychange', () => {
    if (document.visibilityState !== 'visible' && locked) document.exitPointerLock?.();
  });

  // --- Click: lock at click point; while locked: squeeze ---
  addEventListener('pointerdown', (e) => {
    if (!locked){
      x = clamp(e.clientX, 0, innerWidth-1);
      y = clamp(e.clientY, 0, innerHeight-1);
      paint();
      try { document.body.requestPointerLock(); } catch { document.body.requestPointerLock?.(); }
    } else {
      c.classList.remove('implode'); void c.offsetWidth;
      c.classList.add('implode');
      setTimeout(() => c.classList.remove('implode'), 240);
    }
  }, true);

  // Esc to unlock
  addEventListener('keydown', (e) => { if (e.key === 'Escape') document.exitPointerLock?.(); });

  // Keep within bounds on resize
  addEventListener('resize', () => {
    x = clamp(x, 0, innerWidth-1);
    y = clamp(y, 0, innerHeight-1);
    paint();
  });

  // Boot
  paint();
  scheduleSpin();
})();
</script>
</body>
