<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crosshair — clean leave/return (Chrome)</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font:14px/1.5 system-ui}

  /* While the pointer is inside the page (locked OR unlocked soft-follow), hide native cursor */
  .hide-native body, .hide-native body *{ cursor:none !important; }

  :root{--s:34px;--t:2px;--g:18px;--d:3px}
  #c{
    position:fixed;left:0;top:0;width:var(--s);height:var(--s);
    transform:translate(-50%,-50%);pointer-events:none;z-index:2147483646;
    color:#fff;filter:drop-shadow(0 0 1px #000) drop-shadow(0 0 2px #000) drop-shadow(0 0 3px #000);
    display:none; /* we show it only when safely inside the page */
  }
  #c .arm{
    position:absolute;left:50%;top:50%;width:var(--s);height:var(--t);transform-origin:50% 50%;
    background:linear-gradient(90deg,currentColor 0 calc(50% - (var(--g)/2)),
      transparent calc(50% - (var(--g)/2)) calc(50% + (var(--g)/2)),
      currentColor calc(50% + (var(--g)/2)) 100%)}
  #c .arm-a{transform:translate(-50%,-50%) rotate(45deg)}
  #c .arm-b{transform:translate(-50%,-50%) rotate(-45deg)}
  #c .dot{position:absolute;left:50%;top:50%;width:var(--d);height:var(--d);transform:translate(-50%,-50%);border-radius:50%;background:currentColor}

  /* idle spin (random, JS triggers) */
  @keyframes spin{from{transform:translate(-50%,-50%) rotate(0)}to{transform:translate(-50%,-50%) rotate(360deg)}}

  /* click = squeeze */
  #c.implode .arm-a,#c.implode .arm-b{animation:arm-implode 220ms ease-out forwards}
  @keyframes arm-implode{
    0%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(1)}
    60%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(.25)}
    100%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(0)}
  }
  #c.implode .arm-a{--deg:45deg} #c.implode .arm-b{--deg:-45deg}

  @media (prefers-reduced-motion: reduce){
    #c{animation:none !important}
    #c.implode .arm-a,#c.implode .arm-b{animation:none !important}
  }
</style>

<body>
  <!-- Crosshair -->
  <div id="c" aria-hidden="true">
    <span class="arm arm-a"></span>
    <span class="arm arm-b"></span>
    <span class="dot"></span>
  </div>

<script>
(() => {
  // ===== Tuning =====
  const SENS   = 0.55;  // pointer-lock sensitivity
  const DX_CAP = 24, DY_CAP = 24;

  const root = document.documentElement;
  const c    = document.getElementById('c');

  let locked = false;
  let x = innerWidth/2, y = innerHeight/2;

  // When we’ve just re-entered the page, don’t show the crosshair until we get a
  // real in-page move; this prevents a 1-frame “double cursor” on re-entry.
  let pendingShowOnFirstMove = false;

  const clamp = (v,min,max)=> v<min?min : v>max?max : v;
  const now   = ()=> performance.now();
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const prefersReduce = matchMedia('(prefers-reduced-motion: reduce)').matches;
  let lastMoveTs = 0;

  function showCrosshair(){ if (c.style.display!=='block'){ c.style.display='block'; } }
  function hideCrosshair(){ if (c.style.display!=='none'){ c.style.display='none'; } }
  function place(){ c.style.left = x+'px'; c.style.top = y+'px'; }

  // ===== ENTER / LEAVE behavior =====
  window.addEventListener('mouseenter', () => {
    // Inside page: hide native cursor and *do not* show crosshair yet.
    root.classList.add('hide-native');
    pendingShowOnFirstMove = true; // show on next in-page move only
  });
  window.addEventListener('mouseleave', () => {
    // Leaving page: always show OS cursor and hide crosshair.
    root.classList.remove('hide-native');
    pendingShowOnFirstMove = false;
    hideCrosshair();
    // If we were locked, cleanly unlock to avoid being "stuck at edge"
    if (locked) document.exitPointerLock?.();
  });

  // ===== Pre-lock soft follow (so you see the crosshair inside the page) =====
  function preMove(e){
    if (locked) return;
    x = e.clientX; y = e.clientY;
    place();
    // Only show crosshair once we’re definitely inside (first move after enter)
    if (pendingShowOnFirstMove){ pendingShowOnFirstMove = false; showCrosshair(); }
  }
  document.addEventListener('pointermove', preMove, { passive:true });

  // ===== Locked movement (deltas) =====
  const getDX = ev => (ev.movementX ?? ev.webkitMovementX ?? ev.mozMovementX ?? 0);
  const getDY = ev => (ev.movementY ?? ev.webkitMovementY ?? ev.mozMovementY ?? 0);

  function applyDelta(ev){
    if (!locked) return;

    let dx = getDX(ev), dy = getDY(ev);
    if (!dx && !dy) return;

    // cap + scale for feel
    if (dx > DX_CAP) dx = DX_CAP; else if (dx < -DX_CAP) dx = -DX_CAP;
    if (dy > DY_CAP) dy = DY_CAP; else if (dy < -DY_CAP) dy = -DY_CAP;
    dx *= SENS; dy *= SENS;

    // integrate + clamp
    let nx = clamp(x + dx, 0, innerWidth  - 1);
    let ny = clamp(y + dy, 0, innerHeight - 1);

    // If we touch any edge while locked, we hand off immediately:
    //  • Hide crosshair (so it never appears "stuck")
    //  • Unlock pointer (OS cursor appears so you can leave)
    if (nx<=0 || nx>=innerWidth-1 || ny<=0 || ny>=innerHeight-1){
      hideCrosshair();
      document.exitPointerLock?.();
      return;
    }

    x = nx; y = ny; place();
    lastMoveTs = now();
  }

  const onMM  = e => applyDelta(e);
  const onPM  = e => applyDelta(e);
  const onPRU = e => applyDelta(e);

  function addLockedListeners(){
    document.addEventListener('mousemove',        onMM,  true);
    document.addEventListener('pointermove',      onPM,  true);
    document.addEventListener('pointerrawupdate', onPRU, true);
  }
  function removeLockedListeners(){
    document.removeEventListener('mousemove',        onMM,  true);
    document.removeEventListener('pointermove',      onPM,  true);
    document.removeEventListener('pointerrawupdate', onPRU, true);
  }

  // ===== Random idle spin (not on click) =====
  let spinTimer=null;
  function scheduleSpin(){
    clearTimeout(spinTimer);
    spinTimer = setTimeout(()=>{
      if (!prefersReduce && locked && (now()-lastMoveTs > 220)){
        const rev = Math.random()<.5, dur = Math.round(rand(260,680));
        c.style.animation='none'; void c.offsetWidth;
        c.style.animation=`spin ${dur}ms ease-out ${rev?'reverse':'normal'}`;
      }
      scheduleSpin();
    }, Math.round(rand(1200,4200)));
  }

  // ===== Pointer-lock lifecycle =====
  function onLockChange(){
    locked = (document.pointerLockElement === document.body);
    if (locked){
      // In page: hide native cursor, show crosshair where you clicked
      root.classList.add('hide-native');
      pendingShowOnFirstMove = false;
      showCrosshair();
      removeEventListener('pointermove', preMove, true);
      addLockedListeners();
      place();
    } else {
      // Unlocked: go back to soft follow; we’ll hide/show via enter/leave logic
      removeLockedListeners();
      addEventListener('pointermove', preMove, { passive:true });
    }
  }
  document.addEventListener('pointerlockchange', onLockChange);
  document.addEventListener('pointerlockerror',  onLockChange);

  // ===== Click behavior =====
  addEventListener('pointerdown', (e) => {
    if (!locked){
      // Prepare lock at the click point (no jump)
      x = clamp(e.clientX, 0, innerWidth-1);
      y = clamp(e.clientY, 0, innerHeight-1);
      place();
      // Ensure we’re in-page visuals: hide OS cursor, show crosshair
      root.classList.add('hide-native');
      showCrosshair();
      // Request lock; Chrome hides OS cursor automatically
      try { document.body.requestPointerLock(); } catch { document.body.requestPointerLock?.(); }
    } else {
      // Squeeze/implode
      c.classList.remove('implode'); void c.offsetWidth;
      c.classList.add('implode');
      setTimeout(()=>c.classList.remove('implode'), 240);
    }
  }, true);

  // Esc to unlock
  addEventListener('keydown', (e) => { if (e.key === 'Escape') document.exitPointerLock?.(); });

  // Keep within bounds on resize; never recenter
  addEventListener('resize', () => {
    x = clamp(x, 0, innerWidth-1);
    y = clamp(y, 0, innerHeight-1);
    if (locked) place();
  });

  // Boot: start hidden until pointer enters the page and moves once
  hideCrosshair();
  scheduleSpin();
})();
</script>
</body>
