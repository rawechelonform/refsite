<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crosshair — Chrome pointer-lock (sensitivity + edge hand-off)</title>
<style>
  /* Neutral dark bg so crosshair is visible pre/post lock */
  html,body{height:100%;margin:0;background:#111;color:#ddd;font:14px/1.5 system-ui}
  .ui{position:fixed;left:0;right:0;top:0;padding:12px 14px;text-align:center;color:#aab}

  /* HUD (optional; helps verify movement/deltas) */
  .hud{
    position:fixed;left:8px;top:8px;z-index:2147483647;
    font:12px/1.3 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    color:#9cf;background:rgba(0,0,0,.55);border:1px solid #224;
    padding:6px 8px;border-radius:6px;user-select:none;pointer-events:none
  }

  /* Crosshair visuals */
  :root{--s:34px;--t:2px;--g:18px;--d:3px}
  #c{
    position:fixed;left:0;top:0;width:var(--s);height:var(--s);
    transform:translate(-50%,-50%);pointer-events:none;z-index:2147483646;
    color:#fff;filter:drop-shadow(0 0 1px #000) drop-shadow(0 0 2px #000) drop-shadow(0 0 3px #000);
    display:block /* visible pre & post lock */
  }
  #c .arm{
    position:absolute;left:50%;top:50%;width:var(--s);height:var(--t);transform-origin:50% 50%;
    background:linear-gradient(90deg,currentColor 0 calc(50% - (var(--g)/2)),
      transparent calc(50% - (var(--g)/2)) calc(50% + (var(--g)/2)),
      currentColor calc(50% + (var(--g)/2)) 100%)}
  #c .arm-a{transform:translate(-50%,-50%) rotate(45deg)}
  #c .arm-b{transform:translate(-50%,-50%) rotate(-45deg)}
  #c .dot{position:absolute;left:50%;top:50%;width:var(--d);height:var(--d);transform:translate(-50%,-50%);border-radius:50%;background:currentColor}

  /* idle spin (triggered in JS) */
  @keyframes spin{from{transform:translate(-50%,-50%) rotate(0)}to{transform:translate(-50%,-50%) rotate(360deg)}}

  /* click = squeeze */
  #c.implode .arm-a,#c.implode .arm-b{animation:arm-implode 220ms ease-out forwards}
  @keyframes arm-implode{
    0%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(1)}
    60%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(.25)}
    100%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(0)}
  }
  #c.implode .arm-a{--deg:45deg} #c.implode .arm-b{--deg:-45deg}

  @media (prefers-reduced-motion: reduce){
    #c{animation:none !important}
    #c.implode .arm-a,#c.implode .arm-b{animation:none !important}
  }
</style>

<body>
  <div class="ui">Click anywhere to <b>lock</b>. Click while locked = <b>squeeze</b>. Push into an edge → instant hand-off (unlock). Esc also unlocks.</div>
  <div class="hud" id="hud">lock: <b>OFF</b> • x:- y:- • dx:0 dy:0 • src:-</div>

  <!-- Crosshair -->
  <div id="c" aria-hidden="true">
    <span class="arm arm-a"></span>
    <span class="arm arm-b"></span>
    <span class="dot"></span>
  </div>

<script>
(() => {
  // ===== Tunables =====
  const SENS   = 0.55;  // sensitivity scale (lower = less sensitive)
  const DX_CAP = 24;    // cap per-frame raw delta before scaling
  const DY_CAP = 24;

  const c   = document.getElementById('c');
  const hud = document.getElementById('hud');

  let locked = false;
  let x = innerWidth/2, y = innerHeight/2;
  let lastMoveTs = 0;

  const clamp = (v,min,max)=> v<min?min : v>max?max : v;
  const now   = ()=> performance.now();
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const prefersReduce = matchMedia('(prefers-reduced-motion: reduce)').matches;

  function paint(dx=0,dy=0,src='-'){
    c.style.left = x+'px'; c.style.top = y+'px';
    hud.textContent = `lock: ${locked?'ON':'OFF'} • x:${Math.round(x)} y:${Math.round(y)} • dx:${dx} dy:${dy} • src:${src}`;
  }

  // ===== Pre-lock: follow OS cursor so crosshair is always visible =====
  function preMove(e){ if (!locked){ x = e.clientX; y = e.clientY; paint(); } }
  addEventListener('pointermove', preMove, { passive:true });

  // ===== Helpers =====
  const getDX = ev => (ev.movementX ?? ev.webkitMovementX ?? ev.mozMovementX ?? 0);
  const getDY = ev => (ev.movementY ?? ev.webkitMovementY ?? ev.mozMovementY ?? 0);

  function atEdge(nx, ny){
    if (nx <= 0) return 'left';
    if (nx >= innerWidth-1) return 'right';
    if (ny <= 0) return 'top';
    if (ny >= innerHeight-1) return 'bottom';
    return null;
  }
  function pushingOut(side, dx, dy){
    if (side==='left') return dx < 0;
    if (side==='right') return dx > 0;
    if (side==='top') return dy < 0;
    if (side==='bottom') return dy > 0;
    return false;
  }

  // ===== Locked movement (robust: listen to all delta sources on document, capture phase) =====
  function applyDelta(ev, src){
    if (!locked) return;

    let dx = getDX(ev), dy = getDY(ev);
    if (!dx && !dy) return;

    // cap raw spikes
    if (dx >  DX_CAP) dx =  DX_CAP; else if (dx < -DX_CAP) dx = -DX_CAP;
    if (dy >  DY_CAP) dy =  DY_CAP; else if (dy < -DY_CAP) dy = -DY_CAP;

    // scale sensitivity
    dx *= SENS; dy *= SENS;

    // integrate and clamp
    let nx = clamp(x + dx, 0, innerWidth  - 1);
    let ny = clamp(y + dy, 0, innerHeight - 1);

    // Edge hand-off: if you're at an edge AND still pushing outward → unlock immediately
    const side = atEdge(nx, ny);
    if (side && pushingOut(side, dx, dy)){
      c.style.display = 'none';       // hide crosshair this frame to avoid "double cursor"
      document.exitPointerLock?.();   // OS cursor takes over seamlessly
      return;
    }

    x = nx; y = ny;
    lastMoveTs = now();
    paint(dx.toFixed(1),dy.toFixed(1),src);
  }

  // capture:true to avoid other handlers swallowing events
  const onMM  = e => applyDelta(e,'mousemove');
  const onPM  = e => applyDelta(e,'pointermove');
  const onPRU = e => applyDelta(e,'pointerrawupdate');

  function addLocked(){
    document.addEventListener('mousemove',        onMM,  true);
    document.addEventListener('pointermove',      onPM,  true);
    document.addEventListener('pointerrawupdate', onPRU, true);
  }
  function removeLocked(){
    document.removeEventListener('mousemove',        onMM,  true);
    document.removeEventListener('pointermove',      onPM,  true);
    document.removeEventListener('pointerrawupdate', onPRU, true);
  }

  // ===== Idle random spins (not on click) =====
  let spinTimer = null;
  function scheduleSpin(){
    clearTimeout(spinTimer);
    const delay = Math.round(rand(1200, 4200));
    spinTimer = setTimeout(() => {
      const quiet = now() - lastMoveTs > 220;
      if (!prefersReduce && locked && quiet){
        const rev = Math.random() < 0.5;
        const dur = Math.round(rand(260, 680));
        c.style.animation = 'none'; void c.offsetWidth;
        c.style.animation = `spin ${dur}ms ease-out ${rev?'reverse':'normal'}`;
      }
      scheduleSpin();
    }, delay);
  }

  // ===== Pointer-lock lifecycle =====
  function onLockChange(){
    locked = (document.pointerLockElement === document.body);
    if (locked){
      removeEventListener('pointermove', preMove, true);
      addLocked();
      c.style.display = 'block';
      paint();
    } else {
      removeLocked();
      addEventListener('pointermove', preMove, { passive:true });
      // Crosshair will reappear on next preMove when you come back over the page
    }
  }
  addEventListener('pointerlockchange', onLockChange);
  addEventListener('pointerlockerror',  onLockChange);

  // ===== Click: lock at click point; while locked: squeeze =====
  addEventListener('pointerdown', (e) => {
    if (!locked){
      x = clamp(e.clientX, 0, innerWidth-1);
      y = clamp(e.clientY, 0, innerHeight-1);
      paint();
      try { document.body.requestPointerLock(); } catch { document.body.requestPointerLock?.(); }
    } else {
      c.classList.remove('implode'); void c.offsetWidth;
      c.classList.add('implode');
      setTimeout(() => c.classList.remove('implode'), 240);
    }
  }, true);

  // Esc to unlock
  addEventListener('keydown', (e) => { if (e.key === 'Escape') document.exitPointerLock?.(); });

  // Avoid context-menu swallow weirdness while locked
  addEventListener('contextmenu', (e) => { if (locked) e.preventDefault(); }, true);

  // Keep inside bounds on resize
  addEventListener('resize', () => {
    x = clamp(x, 0, innerWidth-1);
    y = clamp(y, 0, innerHeight-1);
    paint();
  });

  // Boot
  paint();
  scheduleSpin();
})();
</script>
</body>
