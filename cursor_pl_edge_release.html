<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pointer-Lock Crosshair — edge release</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#ddd;font:14px/1.5 system-ui}
  .ui{position:fixed;left:0;right:0;top:0;padding:14px;text-align:center;color:#aaa}
  .hint{opacity:.85}

  :root{ --s:34px; --t:2px; --g:18px; --d:3px; }
  #c{
    position:fixed; left:0; top:0; width:var(--s); height:var(--s);
    transform:translate(-50%,-50%); pointer-events:none; z-index:2147483647;
    color:#fff; mix-blend-mode:difference;
    filter:drop-shadow(0 0 .5px rgba(0,0,0,.6)) drop-shadow(0 0 1px rgba(0,0,0,.5));
    display:none; /* only while locked */
  }
  #c .arm{
    position:absolute; left:50%; top:50%; width:var(--s); height:var(--t);
    transform-origin:50% 50%;
    background:linear-gradient(90deg,
      currentColor 0 calc(50% - (var(--g)/2)),
      transparent calc(50% - (var(--g)/2)) calc(50% + (var(--g)/2)),
      currentColor calc(50% + (var(--g)/2)) 100%);
  }
  #c .arm-a{ transform:translate(-50%,-50%) rotate(45deg); }
  #c .arm-b{ transform:translate(-50%,-50%) rotate(-45deg); }
  #c .dot{ position:absolute; left:50%; top:50%; width:var(--d); height:var(--d);
           transform:translate(-50%,-50%); border-radius:50%; background:currentColor; }

  @keyframes spin{ from{transform:translate(-50%,-50%) rotate(0)} to{transform:translate(-50%,-50%) rotate(360deg)} }
  .spin{ animation:spin 360ms ease-out; }
</style>
</head>
<body>
  <div class="ui">
    <div class="hint">
      Click anywhere to <strong>lock</strong> (OS cursor hidden).  
      Push against an edge for a moment to <strong>unlock</strong>, or press <strong>Esc</strong>.
    </div>
  </div>

  <div id="c" aria-hidden="true">
    <span class="arm arm-a"></span>
    <span class="arm arm-b"></span>
    <span class="dot"></span>
  </div>

<script>
(() => {
  const cursor = document.getElementById('c');

  // Pointer-lock state
  let locked = false;
  let x = innerWidth  / 2;
  let y = innerHeight / 2;

  // Edge-release tuning
  const EDGE_MARGIN = 0;        // how close to the edge we consider "at edge"
  const RELEASE_PX  = 28;       // accumulated outward pixels before unlock
  const DECAY_MS    = 140;      // decay window for the accumulator

  // Accumulators for outward pressure at each edge
  let acc = { left:0, right:0, top:0, bottom:0 };
  let lastStamp = performance.now();

  const clamp = (v,min,max)=> v<min?min : v>max?max : v;

  function place(){
    cursor.style.left = x + 'px';
    cursor.style.top  = y + 'px';
  }

  function resetAcc(){
    acc.left = acc.right = acc.top = acc.bottom = 0;
  }

  function decayAcc(now){
    const dt = Math.max(0, now - lastStamp);
    // simple linear decay: drain toward 0 over DECAY_MS
    const k = Math.max(0, 1 - dt / DECAY_MS);
    acc.left  *= k;
    acc.right *= k;
    acc.top   *= k;
    acc.bottom*= k;
    lastStamp = now;
  }

  function onLockedMove(e){
    // Apply deltas
    let nx = x + e.movementX;
    let ny = y + e.movementY;

    // Clamp to viewport
    nx = clamp(nx, EDGE_MARGIN, innerWidth  - 1 - EDGE_MARGIN);
    ny = clamp(ny, EDGE_MARGIN, innerHeight - 1 - EDGE_MARGIN);

    // Detect outward pressure while at edges
    const now = performance.now();
    decayAcc(now);

    // Horizontal outward push
    if (nx <= EDGE_MARGIN && e.movementX < 0) {
      acc.left += -e.movementX;           // pushing further left
    } else if (nx >= innerWidth-1-EDGE_MARGIN && e.movementX > 0) {
      acc.right += e.movementX;           // pushing further right
    } else {
      acc.left = acc.right = 0;           // left edge released
    }

    // Vertical outward push
    if (ny <= EDGE_MARGIN && e.movementY < 0) {
      acc.top += -e.movementY;            // pushing further up
    } else if (ny >= innerHeight-1-EDGE_MARGIN && e.movementY > 0) {
      acc.bottom += e.movementY;          // pushing further down
    } else {
      acc.top = acc.bottom = 0;           // top/bottom edge released
    }

    x = nx; y = ny;
    place();

    // If any accumulator exceeds threshold → unlock pointer lock
    if (acc.left  > RELEASE_PX || acc.right > RELEASE_PX ||
        acc.top   > RELEASE_PX || acc.bottom> RELEASE_PX) {
      document.exitPointerLock?.();
      resetAcc();
    }
  }

  function onLockChange(){
    locked = (document.pointerLockElement === document.body);
    if (locked){
      cursor.style.display = 'block';
      resetAcc(); lastStamp = performance.now();
      place();
      document.addEventListener('mousemove', onLockedMove, true);
    } else {
      cursor.style.display = 'none';
      document.removeEventListener('mousemove', onLockedMove, true);
      resetAcc();
    }
  }

  // Click to lock; if already locked, do a spin pulse
  window.addEventListener('pointerdown', (e) => {
    if (e.clientX >= 0 && e.clientY >= 0 && e.clientX < innerWidth && e.clientY < innerHeight){
      if (!locked){
        document.body.requestPointerLock?.();
      } else {
        cursor.classList.remove('spin'); void cursor.offsetWidth; cursor.classList.add('spin');
      }
    }
  }, true);

  // Clean unlocks
  document.addEventListener('pointerlockchange', onLockChange, false);
  document.addEventListener('pointerlockerror',  onLockChange, false);
  window.addEventListener('blur', () => document.exitPointerLock?.(), false);
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') document.exitPointerLock?.(); });
  // True leave (rare while locked, but keep it)
  document.addEventListener('mouseout', (e)=>{ if (!locked) return; if (e.relatedTarget === null) document.exitPointerLock?.(); }, {passive:true});

  // Keep inside bounds on resize
  window.addEventListener('resize', () => {
    x = clamp(x, EDGE_MARGIN, innerWidth  - 1 - EDGE_MARGIN);
    y = clamp(y, EDGE_MARGIN, innerHeight - 1 - EDGE_MARGIN);
    if (locked) place();
  });
})();
</script>
</body>
</html>
