<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crosshair — hard lock + Space unlock (no edge unlock)</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font:14px/1.5 system-ui}
  .hud{position:fixed;left:8px;top:8px;z-index:2147483647;
       font:12px/1.3 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
       color:#9cf;background:rgba(0,0,0,.55);border:1px solid #224;
       padding:6px 8px;border-radius:6px;user-select:none;pointer-events:none}
  .hint-edge{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
       z-index:2147483647;font:12px/1.3 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
       color:#ccc;background:rgba(0,0,0,.55);border:1px solid #333;
       padding:6px 10px;border-radius:8px;opacity:0;transition:opacity .18s}
  .hint-edge.show{opacity:1}

  :root{ --s:34px; --t:2px; --g:18px; --d:3px; }
  #c{position:fixed;left:0;top:0;width:var(--s);height:var(--s);
     transform:translate(-50%,-50%);pointer-events:none;z-index:2147483646;
     color:#fff;filter:drop-shadow(0 0 1px #000) drop-shadow(0 0 2px #000) drop-shadow(0 0 3px #000);
     display:block}
  #c .arm{position:absolute;left:50%;top:50%;width:var(--s);height:var(--t);transform-origin:50% 50%;
          background:linear-gradient(90deg,currentColor 0 calc(50% - (var(--g)/2)),
          transparent calc(50% - (var(--g)/2)) calc(50% + (var(--g)/2)),
          currentColor calc(50% + (var(--g)/2)) 100%)}
  #c .arm-a{transform:translate(-50%,-50%) rotate(45deg)}
  #c .arm-b{transform:translate(-50%,-50%) rotate(-45deg)}
  #c .dot{position:absolute;left:50%;top:50%;width:var(--d);height:var(--d);
          transform:translate(-50%,-50%);border-radius:50%;background:currentColor}
  @keyframes spin{from{transform:translate(-50%,-50%) rotate(0)}to{transform:translate(-50%,-50%) rotate(360deg)}}
  #c.implode .arm-a,#c.implode .arm-b{animation:arm-implode 220ms ease-out forwards}
  @keyframes arm-implode{
    0%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(1)}
    60%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(.25)}
    100%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(0)}
  }
  #c.implode .arm-a{--deg:45deg} #c.implode .arm-b{--deg:-45deg}
</style>
<body>
  <div class="hud" id="hud">lock: <b>OFF</b> • x:- • y:-</div>
  <div class="hint-edge" id="hint">hold <b>Space</b> to leave</div>

  <div id="c" aria-hidden="true">
    <span class="arm arm-a"></span><span class="arm arm-b"></span><span class="dot"></span>
  </div>

<script>
(() => {
  const cursor = document.getElementById('c');
  const hud    = document.getElementById('hud');
  const hint   = document.getElementById('hint');

  let locked = false;
  let x = innerWidth/2, y = innerHeight/2;

  const clamp = (v,min,max)=> v<min?min : v>max?max : v;
  const now   = ()=> performance.now();
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const prefersReduce = matchMedia('(prefers-reduced-motion: reduce)').matches;

  function paint(){
    cursor.style.left = x+'px'; cursor.style.top = y+'px';
    hud.textContent = `lock: ${locked?'ON':'OFF'} • x:${Math.round(x)} • y:${Math.round(y)}`;
  }

  // PRE-LOCK: follow OS cursor so crosshair is visible before locking
  function preMove(e){ if (!locked){ x=e.clientX; y=e.clientY; paint(); } }
  document.addEventListener('pointermove', preMove, {passive:true});

  // POST-LOCK: deltas; clamp; NO edge unlocks. Just show a hint at edge.
  const EDGE_PAD=0;
  function atEdge(nx,ny){
    if (nx<=EDGE_PAD || nx>=innerWidth-1-EDGE_PAD || ny<=EDGE_PAD || ny>=innerHeight-1-EDGE_PAD) return true;
    return false;
  }
  let lastMoveTs = 0;
  function onLockedMove(e){
    x = clamp(x + e.movementX, 0, innerWidth-1);
    y = clamp(y + e.movementY, 0, innerHeight-1);
    paint();
    lastMoveTs = now();
    // show hint when actually resting at edge
    hint.classList.toggle('show', atEdge(x,y));
  }

  // Space-to-unlock (hold for ~250ms)
  let spaceDown = false, spaceTimer = null;
  const SPACE_HOLD_MS = 250;
  function onKeyDown(e){
    if (e.key === ' ' && locked && !spaceDown){
      spaceDown = true;
      spaceTimer = setTimeout(() => {
        document.exitPointerLock?.();
      }, SPACE_HOLD_MS);
    }
    if (e.key === 'Escape' && locked){
      document.exitPointerLock?.();
    }
  }
  function onKeyUp(e){
    if (e.key === ' '){
      spaceDown = false;
      if (spaceTimer){ clearTimeout(spaceTimer); spaceTimer = null; }
    }
  }
  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  // Idle random spins (not on click)
  let spinTimer = null;
  function scheduleSpin(){
    clearTimeout(spinTimer);
    const delay = Math.round(rand(1200, 4200));
    spinTimer = setTimeout(() => {
      const quiet = now() - lastMoveTs > 220;
      if (!prefersReduce && locked && quiet){
        const reverse = Math.random() < 0.5;
        const dur = Math.round(rand(260, 680));
        cursor.style.animation = 'none'; void cursor.offsetWidth;
        cursor.style.animation = `spin ${dur}ms ease-out ${reverse ? 'reverse':'normal'}`;
      }
      scheduleSpin();
    }, delay);
  }

  // Lock lifecycle
  function onLockChange(){
    locked = (document.pointerLockElement === document.body);
    if (locked){
      document.removeEventListener('pointermove', preMove, true);
      document.addEventListener('mousemove', onLockedMove, true);
    } else {
      document.removeEventListener('mousemove', onLockedMove, true);
      document.addEventListener('pointermove', preMove, {passive:true});
      hint.classList.remove('show');
    }
    paint();
  }
  document.addEventListener('pointerlockchange', onLockChange);
  document.addEventListener('pointerlockerror',  onLockChange);

  // Click: lock at click point; while locked: click = squeeze
  addEventListener('pointerdown', (e) => {
    if (!locked){
      x = clamp(e.clientX, 0, innerWidth-1);
      y = clamp(e.clientY, 0, innerHeight-1);
      paint();
      document.body.requestPointerLock?.();
    } else {
      cursor.classList.remove('implode'); void cursor.offsetWidth;
      cursor.classList.add('implode');
      setTimeout(()=>cursor.classList.remove('implode'), 240);
    }
  }, true);

  // Keep within bounds on resize; no recenter
  addEventListener('resize', () => {
    x = clamp(x, 0, innerWidth-1);
    y = clamp(y, 0, innerHeight-1);
    paint();
  });

  // Boot
  paint(); scheduleSpin();
})();
</script>
</body>
