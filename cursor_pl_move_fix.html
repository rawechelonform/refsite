<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pointer Lock — MOVE FIX (Chrome)</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font:14px/1.5 system-ui}
  .hud{
    position:fixed;left:8px;top:8px;z-index:2147483647;
    font:12px/1.3 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    color:#9cf;background:rgba(0,0,0,.55);border:1px solid #224;
    padding:6px 8px;border-radius:6px;user-select:none;pointer-events:none
  }

  :root{--s:34px;--t:2px;--g:18px;--d:3px}
  #c{
    position:fixed;left:0;top:0;width:var(--s);height:var(--s);
    transform:translate(-50%,-50%);pointer-events:none;z-index:2147483646;
    color:#fff;filter:drop-shadow(0 0 1px #000) drop-shadow(0 0 2px #000) drop-shadow(0 0 3px #000);
    display:block /* visible pre/post lock */
  }
  #c .arm{
    position:absolute;left:50%;top:50%;width:var(--s);height:var(--t);transform-origin:50% 50%;
    background:linear-gradient(90deg,currentColor 0 calc(50% - (var(--g)/2)),
      transparent calc(50% - (var(--g)/2)) calc(50% + (var(--g)/2)),
      currentColor calc(50% + (var(--g)/2)) 100%)}
  #c .arm-a{transform:translate(-50%,-50%) rotate(45deg)}
  #c .arm-b{transform:translate(-50%,-50%) rotate(-45deg)}
  #c .dot{position:absolute;left:50%;top:50%;width:var(--d);height:var(--d);transform:translate(-50%,-50%);border-radius:50%;background:currentColor}

  @keyframes spin{from{transform:translate(-50%,-50%) rotate(0)}to{transform:translate(-50%,-50%) rotate(360deg)}}
  #c.implode .arm-a,#c.implode .arm-b{animation:arm-implode 220ms ease-out forwards}
  @keyframes arm-implode{
    0%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(1)}
    60%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(.25)}
    100%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(0)}
  }
  #c.implode .arm-a{--deg:45deg} #c.implode .arm-b{--deg:-45deg}
</style>
<body>
  <div class="hud" id="hud">lock: <b>OFF</b> • x:- y:- • dx:0 dy:0 • src:-</div>

  <!-- Crosshair -->
  <div id="c" aria-hidden="true">
    <span class="arm arm-a"></span>
    <span class="arm arm-b"></span>
    <span class="dot"></span>
  </div>

<script>
(() => {
  const cursor = document.getElementById('c');
  const hud    = document.getElementById('hud');

  let locked = false;
  let x = innerWidth/2, y = innerHeight/2;
  let lastMoveTs = 0;

  const clamp = (v,min,max)=> v<min?min : v>max?max : v;
  const now   = ()=> performance.now();
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const prefersReduce = matchMedia('(prefers-reduced-motion: reduce)').matches;

  function paint(dx=0,dy=0,src='-'){
    cursor.style.left = x+'px'; cursor.style.top = y+'px';
    hud.textContent = `lock: ${locked?'ON':'OFF'} • x:${Math.round(x)} y:${Math.round(y)} • dx:${dx} dy:${dy} • src:${src}`;
  }

  // PRE-LOCK: follow OS cursor
  function preMove(e){ if (!locked){ x = e.clientX; y = e.clientY; paint(); } }
  document.addEventListener('pointermove', preMove, { passive:true });

  // LOCKED: capture ALL delta sources on **document** in **capture phase**
  function getDX(ev){
    return (ev.movementX ?? ev.webkitMovementX ?? ev.mozMovementX ?? 0);
  }
  function getDY(ev){
    return (ev.movementY ?? ev.webkitMovementY ?? ev.mozMovementY ?? 0);
  }

  function onMouseMove(ev){
    if (!locked) return;
    const dx = getDX(ev), dy = getDY(ev);
    if (dx || dy){ x = clamp(x + dx, 0, innerWidth-1); y = clamp(y + dy, 0, innerHeight-1); lastMoveTs = now(); paint(dx,dy,'mousemove'); }
  }
  function onPointerMove(ev){
    if (!locked) return;
    const dx = getDX(ev), dy = getDY(ev);
    if (dx || dy){ x = clamp(x + dx, 0, innerWidth-1); y = clamp(y + dy, 0, innerHeight-1); lastMoveTs = now(); paint(dx,dy,'pointermove'); }
  }
  function onRaw(ev){
    if (!locked) return;
    const dx = getDX(ev), dy = getDY(ev);
    if (dx || dy){ x = clamp(x + dx, 0, innerWidth-1); y = clamp(y + dy, 0, innerHeight-1); lastMoveTs = now(); paint(dx,dy,'pointerrawupdate'); }
  }

  function addLockedListeners(){
    // capture:true ensures we receive events even if something stops propagation
    document.addEventListener('mousemove',        onMouseMove,   true);
    document.addEventListener('pointermove',      onPointerMove, true);
    document.addEventListener('pointerrawupdate', onRaw,         true);
  }
  function removeLockedListeners(){
    document.removeEventListener('mousemove',        onMouseMove,   true);
    document.removeEventListener('pointermove',      onPointerMove, true);
    document.removeEventListener('pointerrawupdate', onRaw,         true);
  }

  // RANDOM IDLE SPINS
  let spinTimer = null;
  function scheduleSpin(){
    clearTimeout(spinTimer);
    const delay = Math.round(rand(1200,4200));
    spinTimer = setTimeout(() => {
      if (!prefersReduce && locked && (now()-lastMoveTs > 220)){
        const rev = Math.random()<.5, dur = Math.round(rand(260,680));
        cursor.style.animation = 'none'; void cursor.offsetWidth;
        cursor.style.animation = `spin ${dur}ms ease-out ${rev?'reverse':'normal'}`;
      }
      scheduleSpin();
    }, delay);
  }

  // LOCK LIFECYCLE
  function onLockChange(){
    locked = (document.pointerLockElement === document.body);
    if (locked){
      document.removeEventListener('pointermove', preMove, true);
      addLockedListeners();
    } else {
      removeLockedListeners();
      document.addEventListener('pointermove', preMove, { passive:true });
    }
    paint();
  }
  document.addEventListener('pointerlockchange', onLockChange);
  document.addEventListener('pointerlockerror',  onLockChange);

  // CLICK: lock at click point; while locked: squeeze
  document.addEventListener('pointerdown', (e) => {
    if (!locked){
      x = clamp(e.clientX, 0, innerWidth-1);
      y = clamp(e.clientY, 0, innerHeight-1);
      paint();
      // Request pointer lock; try optional unadjustedMovement for some devices
      const opts = (Element.prototype.requestPointerLock.length ? undefined : { unadjustedMovement: true });
      try { document.body.requestPointerLock(opts); } catch { document.body.requestPointerLock?.(); }
    } else {
      cursor.classList.remove('implode'); void cursor.offsetWidth;
      cursor.classList.add('implode');
      setTimeout(() => cursor.classList.remove('implode'), 240);
    }
  }, true);

  // ONLY Esc unlocks
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') document.exitPointerLock?.(); });

  // Avoid context-menu swallow bugs while locked
  document.addEventListener('contextmenu', (e) => { if (locked) e.preventDefault(); }, true);

  // Keep within bounds on resize
  window.addEventListener('resize', () => {
    x = clamp(x, 0, innerWidth-1);
    y = clamp(y, 0, innerHeight-1);
    paint();
  });

  // Boot
  paint(); scheduleSpin();
})();
</script>
</body>
