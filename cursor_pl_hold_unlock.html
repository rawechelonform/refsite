<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pointer-Lock Crosshair — hold-at-edge unlock</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#ddd;font:14px/1.5 system-ui}
  .ui{position:fixed;left:0;right:0;top:0;padding:14px;text-align:center;color:#aaa}
  .hint{opacity:.85}

  :root{ --s:34px; --t:2px; --g:18px; --d:3px; }
  #c{
    position:fixed; left:0; top:0; width:var(--s); height:var(--s);
    transform:translate(-50%,-50%); pointer-events:none; z-index:2147483647;
    color:#fff; mix-blend-mode:difference;
    filter:drop-shadow(0 0 .5px rgba(0,0,0,.6)) drop-shadow(0 0 1px rgba(0,0,0,.5));
    display:none; /* visible only while locked */
  }
  #c .arm{
    position:absolute; left:50%; top:50%; width:var(--s); height:var(--t);
    transform-origin:50% 50%;
    background:linear-gradient(90deg,
      currentColor 0 calc(50% - (var(--g)/2)),
      transparent calc(50% - (var(--g)/2)) calc(50% + (var(--g)/2)),
      currentColor calc(50% + (var(--g)/2)) 100%);
  }
  #c .arm-a{ transform:translate(-50%,-50%) rotate(45deg); }
  #c .arm-b{ transform:translate(-50%,-50%) rotate(-45deg); }
  #c .dot{ position:absolute; left:50%; top:50%; width:var(--d); height:var(--d);
           transform:translate(-50%,-50%); border-radius:50%; background:currentColor; }

  /* Idle spin (random) */
  @keyframes spin{ from{transform:translate(-50%,-50%) rotate(0)} to{transform:translate(-50%,-50%) rotate(360deg)} }

  /* Click = squeeze (implode) */
  #c.implode .arm-a, #c.implode .arm-b{ animation: arm-implode 220ms ease-out forwards; }
  @keyframes arm-implode{
    0%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(1)}
    60%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(.25)}
    100%{transform:translate(-50%,-50%) rotate(var(--deg,45deg)) scaleX(0)}
  }
  #c.implode .arm-a{ --deg:45deg; }
  #c.implode .arm-b{ --deg:-45deg; }

  @media (prefers-reduced-motion: reduce){
    #c{ animation:none !important; }
    #c.implode .arm-a, #c.implode .arm-b{ animation:none !important; }
  }
</style>
</head>
<body>
  <div class="ui">
    <div class="hint">
      Click to <strong>lock</strong> (OS cursor hides). Click again = <strong>squeeze</strong>.<br>
      Hold at an edge (~220ms) while pushing outward to <strong>unlock and leave</strong>. Press <strong>Esc</strong> to unlock anytime.
    </div>
  </div>

  <div id="c" aria-hidden="true">
    <span class="arm arm-a"></span>
    <span class="arm arm-b"></span>
    <span class="dot"></span>
  </div>

<script>
(() => {
  const cursor = document.getElementById('c');

  // ---- State ----
  let locked = false;
  let x = innerWidth  / 2;
  let y = innerHeight / 2;

  const clamp = (v,min,max)=> v<min?min : v>max?max : v;
  const now  = ()=> performance.now();
  const rand = (a,b)=> Math.random()*(b-a)+a;
  const prefersReduce = matchMedia('(prefers-reduced-motion: reduce)').matches;

  function place(){ cursor.style.left = x + 'px'; cursor.style.top  = y + 'px'; }

  // ---- Idle spins (random; not on click) ----
  let idleTimer = null, lastMoveTs = 0;
  function scheduleSpin(){
    clearTimeout(idleTimer);
    const delay = Math.round(rand(1200, 4200));
    idleTimer = setTimeout(() => {
      const recent = now() - lastMoveTs < 220;
      if (!prefersReduce && locked && !recent){
        const reverse = Math.random() < 0.5;
        const dur = Math.round(rand(260, 680));
        cursor.style.animation = 'none'; void cursor.offsetWidth;
        cursor.style.animation = `spin ${dur}ms ease-out ${reverse ? 'reverse' : 'normal'}`;
      }
      scheduleSpin();
    }, delay);
  }

  // ---- Hold-at-edge unlock (no recenter, no jump) ----
  const EDGE = 0;            // treat 0.. as edge
  const HOLD_MS = 220;       // dwell to trigger unlock
  let edgeSide = null;       // 'left'|'right'|'top'|'bottom' or null
  let edgeSince = 0;

  function atEdge(nx, ny){
    if (nx <= EDGE) return 'left';
    if (nx >= innerWidth-1-EDGE) return 'right';
    if (ny <= EDGE) return 'top';
    if (ny >= innerHeight-1-EDGE) return 'bottom';
    return null;
  }
  function pushingOutward(side, dx, dy){
    if (side === 'left')   return dx < 0;
    if (side === 'right')  return dx > 0;
    if (side === 'top')    return dy < 0;
    if (side === 'bottom') return dy > 0;
    return false;
  }

  function onLockedMove(e){
    const dx = e.movementX;
    const dy = e.movementY;

    let nx = clamp(x + dx, 0, innerWidth  - 1);
    let ny = clamp(y + dy, 0, innerHeight - 1);

    const side = atEdge(nx, ny);

    // Edge dwell logic
    const t = now();
    if (side){
      // only start/accumulate dwell if still pushing outward
      if (pushingOutward(side, dx, dy)){
        if (edgeSide !== side){ edgeSide = side; edgeSince = t; }
        // if held long enough, unlock (OS cursor comes back, no recenter)
        if (t - edgeSince >= HOLD_MS){
          document.exitPointerLock?.();
          edgeSide = null; edgeSince = 0;
          return; // stop moving while unlocking
        }
      } else {
        // touching edge but not pushing outward: cancel dwell
        edgeSide = null; edgeSince = 0;
      }
    } else {
      edgeSide = null; edgeSince = 0;
    }

    x = nx; y = ny;
    place();
    lastMoveTs = t;
  }

  // ---- Lock lifecycle (no recenter) ----
  function onLockChange(){
    locked = (document.pointerLockElement === document.body);
    if (locked){
      cursor.style.display = 'block';
      place();
      document.addEventListener('mousemove', onLockedMove, true);
    } else {
      cursor.style.display = 'none';
      document.removeEventListener('mousemove', onLockedMove, true);
      edgeSide = null; edgeSince = 0;
    }
  }

  // ---- Click behavior ----
  window.addEventListener('pointerdown', (e) => {
    if (!locked){
      // initialize to the click point so there’s no jump
      x = clamp(e.clientX, 0, innerWidth  - 1);
      y = clamp(e.clientY, 0, innerHeight - 1);
      document.body.requestPointerLock?.();
    } else {
      cursor.classList.remove('implode'); void cursor.offsetWidth;
      cursor.classList.add('implode');
      setTimeout(() => cursor.classList.remove('implode'), 240);
    }
  }, true);

  // Track last motion time for spin suppression
  window.addEventListener('pointermove', (e) => { if (locked) lastMoveTs = now(); }, {passive:true});

  // Pointer lock events
  document.addEventListener('pointerlockchange', onLockChange, false);
  document.addEventListener('pointerlockerror',  onLockChange, false);

  // Esc always unlocks (expected)
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') document.exitPointerLock?.(); });

  // Keep within bounds on resize; no recenter
  window.addEventListener('resize', () => {
    x = clamp(x, 0, innerWidth  - 1);
    y = clamp(y, 0, innerHeight - 1);
    if (locked) place();
  });

  // Boot
  scheduleSpin();
})();
</script>
</body>
</html>

